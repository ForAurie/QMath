#ifndef POLYNOMIAL_H
#define POLYNOMIAL_H
#include <vector>
#include <complex>
#include <cmath>
#include <climits>
#include <iostream>
#include <algorithm>
#include <tuple>
#include <mutex>
#include <type_traits>

#include <cstddef>
#include <cstdint>

// 尝试使用 C++20 标准库 (最推荐，如果编译器支持)
#if defined(__cplusplus) && __cplusplus >= 202002L
#include <bit>
namespace Polynomial {
    inline int log2Floor(size_t n) { return static_cast<int>(std::bit_width(n)) - 1; }
}
// MSVC (Windows)
#elif defined(_MSC_VER)
#include <intrin.h>
#pragma intrinsic(_BitScanReverse64)
#pragma intrinsic(_BitScanReverse)
namespace Polynomial {
    inline int log2Floor(size_t n) {
        unsigned long index;
        if constexpr (sizeof(size_t) == 8) {
            if (_BitScanReverse64(&index, static_cast<unsigned __int64>(n))) return static_cast<int>(index);
        } else {
            if (_BitScanReverse(&index, static_cast<unsigned long>(n))) return static_cast<int>(index);
        }
        return -1; 
    }
}
// GCC / Clang / ICC (原有逻辑保留)
#elif defined(__GNUC__) || defined(__clang__)
namespace Polynomial {
    inline int log2Floor(size_t n) { return (static_cast<int>(sizeof(n) * 8) - 1) - __builtin_clzll(static_cast<unsigned long long>(n)); }
}
// 其他未知编译器的纯 C++ 回退方案 (Portable Fallback)
#else
namespace Polynomial {
    inline int log2Floor(size_t n) {
        if (n == 0) return -1;
        int log = 0;
        while (n >>= 1) ++log;
        return log;
    }
}
#endif

namespace Polynomial {
    inline int log2Ceil(size_t n) {
        if (n == 1) return 0;
        return log2Floor(n - 1) + 1;
    }

    constexpr double PI2 = 6.283185307179586476925286766559005768394338798750211641949889;
    inline std::complex<double> expn(size_t n) { return std::complex<double>(std::cos(PI2 / n), std::sin(PI2 / n)); }
    inline std::complex<double> T2TFFT(double x) { return std::complex<double>(x, 0); }
    inline double TFFT2T(std::complex<double> x) { return x.real(); }

    // 老版本
    // template<typename TFFT, TFFT (*expn)(long long n)>
    // inline void DFT(std::vector<TFFT>& a) {
    //     TFFT t;
    //     std::vector<TFFT> w(a.size() >> 1, TFFT(1));
    //     for (size_t l2 = 1; l2 < a.size(); l2 <<= 1) {
    //         const TFFT wn = expn(l2 << 1);
    //         for (auto i = w.begin() + 1, j = w.begin(), ed = w.begin() + l2; i != ed; ++i, ++j) (*i) = (*j) * wn;
    //         for (auto i = a.begin(); i != a.end(); i += l2) {
    //             auto id = w.begin(), ed = w.begin() + l2;
    //             for (auto j = i + l2; id != ed; ++i, ++j, ++id) {
    //                 auto &x = *i, &y = *j;
    //                 t = (*id) * y, y = x - t, x += t;
    //             }
    //         }
    //     }
    // }
    // template<typename TFFT, TFFT (*expn)(long long n)>
    // inline void IDFT(std::vector<TFFT>& a) {
    //     TFFT t;
    //     std::vector<TFFT> w(a.size() >> 1, TFFT(1));
    //     for (size_t l2 = 1; l2 < a.size(); l2 <<= 1) {
    //         const TFFT wn = expn(-(long long) (l2 << 1));
    //         for (auto i = w.begin() + 1, j = w.begin(), ed = w.begin() + l2; i != ed; ++i, ++j) (*i) = (*j) * wn;
    //         for (auto i = a.begin(); i != a.end(); i += l2) {
    //             auto id = w.begin(), ed = w.begin() + l2;
    //             for (auto j = i + l2; id != ed; ++i, ++j, ++id) {
    //                 auto &x = *i, &y = *j;
    //                 t = (*id) * y, y = x - t, x += t;
    //             }
    //         }
    //     }
    // }
    // template<typename T = double, typename TFFT = std::complex<double>,
    //         TFFT (*T2TFFT)(T) = funcT2FFT,
    //         T (*TFFT2T)(TFFT) = funcFFT2T,
    //         TFFT (*expn)(long long n) = funcFFT
    //         >

    template<typename T = double,
             typename TFFT = std::complex<double>,
             auto T2TFFT = T2TFFT,
             auto TFFT2T = TFFT2T,
             auto expn = expn
             >
    class Polynomial:public std::vector<T> {
    private:
        static std::vector<TFFT>& get_unit_roots() {
            thread_local static std::vector<TFFT> unitRoots = {TFFT(1)};
            return unitRoots;
        }
        static size_t& get_root_size() {
            thread_local static size_t sz = 1;
            return sz;
        }
        static void ensure_precomputed(size_t n) {
            auto& unitRoots = get_unit_roots();
            auto& sz = get_root_size();
            if (sz < n) {
                unitRoots.resize(n);
                do {
                    const TFFT wn = expn(sz << 2);
                    for (size_t i = 0; i < sz; ++i) unitRoots[sz + i] = unitRoots[i] * wn;
                    sz <<= 1;
                } while (sz < n);
            }
        }
        inline void DFT(std::vector<TFFT>& a) {
            auto& unitRoots = get_unit_roots();
            for(size_t l2 = a.size() >> 1; l2; l2 >>= 1) {
                for(auto i = a.begin(), ww = unitRoots.begin(); i != a.end(); i += l2 << 1, ++ww) {
                    for(auto uu = i, vv = i + l2; uu != i + l2; ++uu, ++vv) {
                        auto &u = *uu, &v = *vv, &w = *ww;
                        std::tie(u, v) = std::pair{u + v * w, u - v * w};
                    }
                }
            }
        }
        inline void IDFT(std::vector<TFFT>& a) {
            auto& unitRoots = get_unit_roots();
            for(size_t l2 = 1; l2 < a.size(); l2 <<= 1) {
                for(auto i = a.begin(), ww = unitRoots.begin(); i != a.end(); i += l2 << 1, ++ww) {
                    for(auto uu = i, vv = i + l2; uu != i + l2; ++uu, ++vv) {
                        auto &u = *uu, &v = *vv, &w = *ww;
                        std::tie(u, v) = std::pair{u + v, (u - v) * w};
                    }
                }
            }
            reverse(a.begin() + 1, a.end());
        }
    public:
        static void init() {
            get_unit_roots().clear();
            get_unit_roots().shrink_to_fit();
            get_unit_roots().push_back(TFFT(1));
            get_root_size() = 1;
        }
        using std::vector<T>::operator[];
        Polynomial(const size_t& n = 0, const T& x = T(0)): std::vector<T>(n, x) {}
        Polynomial(const Polynomial& o): std::vector<T>(o) {}
        Polynomial& operator=(const Polynomial& o) {
            this->resize(o.size());
            for (auto i = this->begin(), j = o.begin(); i != this->end(); ++i, ++j) (*i) = (*j);
            return *this;
        }
        Polynomial derivative() const {
            if (this->empty()) return Polynomial();
            Polynomial res(this->size() - 1, 0);
            for (size_t i = 0; i < res.size(); i++) res[i] = T(i + 1) * operator[](i + 1);
            return res;
        }
        Polynomial integral() const {
            Polynomial res(this->size() + 1);
            for (size_t i = 1; i < res.size(); i++) res[i] = operator[](i - 1) / T(i);
            return res;
        }
        Polynomial& derivativeSelf() {
            if (this->empty()) return *this;
            for (size_t i = 0; i < this->size() - 1; i++) operator[](i) = T(i + 1) * operator[](i + 1);
            this->pop_back();
            return *this;
        }
        Polynomial& integralSelf() {
            this->push_back(T(0));
            for (size_t i = this->size() - 1; i > 0; i--) operator[](i) = operator[](i - 1) / T(i);
            this->front() = T(0);
            return *this;
        }
        T calcIntegral(const T& x) const {
            T tmp(x), res(0);
            for (size_t i = 0; i < this->size(); i++, tmp *= x) res += operator[](i) / T(i + 1) * tmp; 
            return res;
        }
        T calcDerivative(const T &x) const {
            T tmp(1), res(0);
            for (size_t i = 1; i < this->size(); i++, tmp *= x) res += operator[](i) * T(i) * tmp;
            return res;
        }
        T calc(const T &x) {
            T tmp(1), res(0);
            for (auto i = this->begin(); i != this->end(); ++i, tmp *= x) res += (*i) * tmp;
            return res;
        }
        Polynomial operator+(const Polynomial& o) const {
            Polynomial res(*this);
            if (this->size() < o.size()) res.resize(o.size(), T(0));
            for (auto i = res.begin(), j = o.begin(); j != o.end(); ++i, ++j) (*i) += (*j);
            return res;
        }
        Polynomial& operator+=(const Polynomial& o) {
            if (this->size() < o.size()) this->resize(o.size(), T(0));
            for (auto i = this->begin(), j = o.begin(); j != o.end(); ++i, ++j) (*i) += (*j);
            return *this;
        }
        Polynomial operator-(const Polynomial& o) const {
            Polynomial res(*this);
            if (this->size() < o.size()) res.resize(o.size(), T(0));
            for (auto i = res.begin(), j = o.begin(); j != o.end(); ++i, ++j) (*i) -= (*j);
            return res;
        }
        Polynomial& operator-=(const Polynomial& o) {
            if (this->size() < o.size()) this->resize(o.size(), T(0));
            for (auto i = this->begin(), j = o.begin(); j != o.end(); ++i, ++j) (*i) -= (*j);
            return *this;
        }
        Polynomial operator*(const T& o) const {
            Polynomial res(*this);
            for (auto& i: res) i *= o;
            return res;
        }
        Polynomial& operator*=(const T& o) {
            for (auto& i: *this) i *= o;
            return *this;
        }
        Polynomial operator/(T o) const {
            Polynomial res(*this);
            o = T(1) / o;
            for (auto& i: res) i *= o;
            return res;
        }
        Polynomial& operator/=(T o) {
            o = T(1) / o;
            for (auto& i: *this) i *= o;
            return *this;
        }
        Polynomial& operator*=(const Polynomial& o) {
            if (std::min(this->size(), o.size()) <= 64) {
                if (this->empty() || o.empty()) return *this = Polynomial(0, T(0));
                Polynomial res(this->size() + o.size() - 1, T(0));
                auto p = res.begin();
                for (auto i = this->begin(); i != this->end(); ++i, ++p) {
                    auto k = p;
                    for (auto j = o.begin(); j != o.end(); ++j, ++k) (*k) += (*i) * (*j);
                }
                return *this = res;
            }
            const size_t n = size_t(1) << log2Ceil(this->size() + o.size() - 1);
            ensure_precomputed(n);
            if constexpr (std::is_same<TFFT, std::complex<T>>::value) {
                std::vector<std::complex<T>> a(n);
                {
                    auto j = a.begin();
                    for (auto i = this->begin(); i != this->end(); ++i, ++j) j->real(*i);
                }
                {
                    auto j = a.begin();
                    for (auto i = o.begin(); i != o.end(); ++i, ++j) j->imag(*i);
                }
                DFT(a);
                for (auto& i : a) i *= i;
                IDFT(a);
                this->resize(this->size() + o.size() - 1, T(0));
                const T div = T(1) / T(n << 1);
                for (size_t i = 0; i < this->size(); i++) operator[](i) = a[i].imag() * div;
                return *this;
            } else {
                if constexpr (std::is_same<T, TFFT>::value) {
                    const size_t len = this->size() + o.size() - 1;
                    this->resize(n, T(0));
                    std::vector<TFFT> b(o); b.resize(n, T(0));
                    DFT(*this), DFT(b);
                    for (auto i = this->begin(), j = b.begin(); i != this->end(); ++i, ++j) (*i) *= (*j);
                    IDFT(*this);
                    this->resize(len);
                    const TFFT div = TFFT(1) / TFFT(n);
                    for (auto& i : *this) i *= div;
                    return *this;
                } else {
                    std::vector<TFFT> a(n), b(n);
                    {
                        auto j = a.begin();
                        for (auto i = this->begin(); i != this->end(); ++i, ++j) (*j) = T2TFFT(*i);
                    }
                    {
                        auto j = b.begin();
                        for (auto i = o.begin(); i != o.end(); ++i, ++j) (*j) = T2TFFT(*i);
                    }
                    DFT(a), DFT(b);
                    for (auto i = a.begin(), j = b.begin(); i != a.end(); ++i, ++j) (*i) *= (*j);
                    IDFT(a);
                    this->resize(this->size() + o.size() - 1, T(0));
                    const TFFT div = TFFT(1) / TFFT(n);
                    for (size_t i = 0; i < this->size(); i++) operator[](i) = TFFT2T(a[i] * div);
                    return *this;
                }
            }
        }
        Polynomial operator*(const Polynomial& o) const {
            Polynomial res(*this);
            return res *= o;
        }
        Polynomial operator%(size_t n) const {
            Polynomial res(*this);
            res.resize(n);
            return res;
        }
        Polynomial& operator%=(size_t n) {
            this->resize(n);
            return *this;
        }
        Polynomial inv() const {
            if (this->size() == 1) return Polynomial(1, T(1) / this->front());
            Polynomial b = ((*this) % ((this->size() + 1) >> 1)).inv();
            return ((b + b) - b * b * *this) % this->size();
        }
        Polynomial& invSelf() {
            if (this->size() == 1) return *this = Polynomial(1, T(1) / this->front());
            Polynomial b = ((*this) % ((this->size() + 1) >> 1)).inv();
            return *this = ((b + b) - b * b * *this) % this->size();
        }
        Polynomial ln() const { return (this->derivative() * this->inv()).integralSelf() %= this->size(); }
        Polynomial& lnSelf() {
            size_t n = this->size();
            *this = this->derivative() * this->inv();
            this->integralSelf() %= n;
            return *this;
        }
        Polynomial exp() const {
            if (this->empty()) return Polynomial(0, T(0));
            if (this->size() == 1) return Polynomial(1, T(1));
            Polynomial b = ((*this) % ((this->size() + 1) >> 1)).exp();
            return b + b * (*this - (b % this->size()).ln()) % this->size();
        }
        Polynomial& expSelf() {
            if (this->empty()) return *this = Polynomial(0, T(0));
            if (this->size() == 1) return *this = Polynomial(1, T(1));
            Polynomial b = ((*this) % ((this->size() + 1) >> 1)).exp();
            return *this = b + b * (*this - (b % this->size()).ln()) % this->size();
        }
        Polynomial sqrt() const {
            if (this->empty()) return Polynomial(0, T(0));
            if (this->size() == 1) return Polynomial(1, T(1));
            Polynomial b = ((*this) % ((this->size() + 1) >> 1)).sqrt();
            return (*this + b * b) * ((b + b) % this->size()).inv() % this->size();
        }
        Polynomial& sqrtSelf() {
            if (this->empty()) return *this = Polynomial(0, T(0));
            if (this->size() == 1) return *this = Polynomial(1, T(1));
            Polynomial b = ((*this) % ((this->size() + 1) >> 1)).sqrt();
            return *this = (*this + b * b) * ((b + b) % this->size()).inv() % this->size(); 
        }
        Polynomial operator|(const Polynomial& o) const {
            if (std::min(this->size(), o.size()) <= 64) {
                if (this->empty() || o.empty()) return Polynomial(0, T(0));
                Polynomial res(size_t(1) << log2Ceil(std::max(this->size(), o.size())), T(0));
                for (size_t i = 0; i < this->size(); i++)
                    for (size_t j = 0; j < o.size(); j++)
                        res[i | j] += operator[](i) * o[j];
                return res;
            }
            const size_t lgn = log2Ceil(std::max(this->size(), o.size()));
            const size_t n = size_t(1) << lgn;
            Polynomial tmp1(*this), tmp2(o);
            tmp1.resize(n, T(0));
            tmp2.resize(n, T(0));
            for (size_t i = 0; i < lgn; i++) {
                for (size_t S = 0; S < n; S++) {
                    if ((S >> i) & 1) {
                        tmp1[S] += tmp1[S ^ (size_t(1) << i)];
                        tmp2[S] += tmp2[S ^ (size_t(1) << i)];
                    }
                }
            }
            for (size_t i = 0; i < n; i++) tmp1[i] *= tmp2[i];
            for (size_t i = 0; i < lgn; i++) {
                for (size_t S = 0; S < n; S++) {
                    if ((S >> i) & 1) tmp1[S] -= tmp1[S ^ (size_t(1) << i)];
                }
            }
            return tmp1;
        }
        Polynomial& operator|=(const Polynomial& o) {
            if (std::min(this->size(), o.size()) <= 64) {
                if (this->empty() || o.empty()) return *this = Polynomial(0, T(0));
                Polynomial res(size_t(1) << log2Ceil(std::max(this->size(), o.size())), T(0));
                for (size_t i = 0; i < this->size(); i++)
                    for (size_t j = 0; j < o.size(); j++)
                        res[i | j] += operator[](i) * o[j];
                return *this = res;
            }
            const size_t lgn = log2Ceil(std::max(this->size(), o.size()));
            const size_t n = size_t(1) << lgn;
            Polynomial tmp(o);
            this->resize(n, T(0));
            tmp.resize(n, T(0));
            for (size_t i = 0; i < lgn; i++) {
                for (size_t S = 0; S < n; S++) {
                    if ((S >> i) & 1) {
                        operator[](S) += operator[](S ^ (size_t(1) << i));
                        tmp[S] += tmp[S ^ (size_t(1) << i)];
                    }
                }
            }
            for (size_t i = 0; i < n; i++) operator[](i) *= tmp[i];
            for (size_t i = 0; i < lgn; i++)
                for (size_t S = 0; S < n; S++)
                    if ((S >> i) & 1) operator[](S) -= operator[](S ^ (size_t(1) << i));;
            return *this;
        }
        Polynomial operator&(const Polynomial& o) const {
            if (std::min(this->size(), o.size()) <= 64) {
                if (this->empty() || o.empty()) return Polynomial(0, T(0));
                Polynomial res(size_t(1) << log2Ceil(std::max(this->size(), o.size())), T(0));
                for (size_t i = 0; i < this->size(); i++)
                    for (size_t j = 0; j < o.size(); j++)
                        res[i & j] += operator[](i) * o[j];
                return res;
            }
            const size_t lgn = log2Ceil(std::max(this->size(), o.size()));
            const size_t n = size_t(1) << lgn;
            Polynomial tmp1(*this), tmp2(o);
            tmp1.resize(n, T(0));
            tmp2.resize(n, T(0));
            for (size_t i = 0; i < lgn; i++) {
                for (size_t S = 0; S < n; S++) {
                    if ((S >> i) & 1) continue;
                    tmp1[S] += tmp1[S ^ (size_t(1) << i)];
                    tmp2[S] += tmp2[S ^ (size_t(1) << i)];
                }
            }
            for (size_t i = 0; i < n; i++) tmp1[i] *= tmp2[i];
            for (size_t i = 0; i < lgn; i++) {
                for (size_t S = 0; S < n; S++) {
                    if ((S >> i) & 1) continue;
                    tmp1[S] -= tmp1[S ^ (size_t(1) << i)];
                }
            }
            return tmp1;
        }
        Polynomial& operator&=(const Polynomial& o) {
            if (std::min(this->size(), o.size()) <= 64) {
                if (this->empty() || o.empty()) return *this = Polynomial(0, T(0));
                Polynomial res(size_t(1) << log2Ceil(std::max(this->size(), o.size())), T(0));
                for (size_t i = 0; i < this->size(); i++)
                    for (size_t j = 0; j < o.size(); j++)
                        res[i & j] += operator[](i) * o[j];
                return *this = res;
            }
            const size_t lgn = log2Ceil(std::max(this->size(), o.size()));
            const size_t n = size_t(1) << lgn;
            Polynomial tmp(o);
            this->resize(n, T(0));
            tmp.resize(n, T(0));
            for (size_t i = 0; i < lgn; i++) {
                for (size_t S = 0; S < n; S++) {
                    if ((S >> i) & 1) continue;
                    operator[](S) += operator[](S ^ (size_t(1) << i));
                    tmp[S] += tmp[S ^ (size_t(1) << i)];
                }
            }
            for (size_t i = 0; i < n; i++) operator[](i) *= tmp[i];
            for (size_t i = 0; i < lgn; i++) {
                for (size_t S = 0; S < n; S++) {
                    if ((S >> i) & 1) continue;
                    operator[](S) -= operator[](S ^ (size_t(1) << i));;
                }
            }
            return *this;
        }
        Polynomial operator^(const Polynomial& o) const {
            if (std::min(this->size(), o.size()) <= 64) {
                if (this->empty() || o.empty()) return Polynomial(0, T(0));
                Polynomial res(size_t(1) << log2Ceil(std::max(this->size(), o.size())), T(0));
                for (size_t i = 0; i < this->size(); i++)
                    for (size_t j = 0; j < o.size(); j++)
                        res[i ^ j] += operator[](i) * o[j];
                return res;
            }
            const size_t n = size_t(1) << log2Ceil(std::max(this->size(), o.size()));
            Polynomial tmp1(*this), tmp2(o);
            for (size_t l = 2; l <= n; l <<= 1) {
                const size_t l2 = l >> 1;
                for (size_t i = 0; i < n; i += l) {
                    for (size_t j = i; j < i + l2; j++) {
                        tmp1[j] += tmp1[j + l2];
                        tmp1[j + l2] = tmp1[j] - tmp1[j + l2] - tmp1[j + l2];
                        tmp2[j] += tmp2[j + l2];
                        tmp2[j + l2] = tmp2[j] - tmp2[j + l2] - tmp2[j + l2];
                    }
                }
            }
            for (size_t i = 0; i < n; i++) tmp1[i] *= tmp2[i];
            const T div2 = T(1) / T(2);
            for (size_t l = 2; l <= n; l <<= 1) {
                const size_t l2 = l >> 1;
                for (size_t i = 0; i < n; i += l) {
                    for (size_t j = i; j < i + l2; j++) {
                        tmp1[j] += tmp1[j + l2];
                        tmp1[j] *= div2;
                        tmp1[j + l2] = tmp1[j] - tmp1[j + l2];
                    }
                }
            }
            return tmp1;
        }
        Polynomial& operator^=(const Polynomial& o) {
            if (std::min(this->size(), o.size()) <= 64) {
                if (this->empty() || o.empty()) return *this = Polynomial(0, T(0));
                Polynomial res(size_t(1) << log2Ceil(std::max(this->size(), o.size())), T(0));
                for (size_t i = 0; i < this->size(); i++)
                    for (size_t j = 0; j < o.size(); j++)
                        res[i ^ j] += operator[](i) * o[j];
                return *this = res;
            }
            const size_t n = size_t(1) << log2Ceil(std::max(this->size(), o.size()));
            Polynomial tmp(o);
            for (size_t l = 2; l <= n; l <<= 1) {
                const size_t l2 = l >> 1;
                for (size_t i = 0; i < n; i += l) {
                    for (size_t j = i; j < i + l2; j++) {
                        operator[](j) += operator[](j + l2);
                        operator[](j + l2) = operator[](j) - operator[](j + l2) - operator[](j + l2);
                        tmp[j] += tmp[j + l2];
                        tmp[j + l2] = tmp[j] - tmp[j + l2] - tmp[j + l2];
                    }
                }
            }
            for (size_t i = 0; i < n; i++) operator[](i) *= tmp[i];
            const T div2 = T(1) / T(2);
            for (size_t l = 2; l <= n; l <<= 1) {
                const size_t l2 = l >> 1;
                for (size_t i = 0; i < n; i += l) {
                    for (size_t j = i; j < i + l2; j++) {
                        operator[](j) += operator[](j + l2);
                        operator[](j) *= div2;
                        operator[](j + l2) = operator[](j) - operator[](j + l2);
                    }
                }
            }
            return *this;
        }
        friend std::ostream& operator<<(std::ostream& os, const Polynomial& p) {
            os << "f(x) = ";
            for (size_t i = 0; i < p.size(); i++) {
                os << p[i] << "x ^ " << i;
                if (i + 1 != p.size()) os << " + ";
            }
            return os;
        }
    };
}
/////////////////////////////////////////////

// #ifndef MODULAR_H
// #define MODULAR_H
// namespace Modular {
//     template <typename T = int, const T MOD = 998244353, typename MCT = unsigned long long>
//     class Modular {
//     private:
//         T value;
//         // T exgcd(const T& a, const T& b, T& x, T& y) const {
//         //     if (b == 0) {
//         //         x = 1, y = 0;
//         //         return a;
//         //     }
//         //     T g = exgcd(b, a % b, y, x);
//         //     y -= static_cast<MultiplicationType>(a / b) * static_cast<MultiplicationType>(x) % MOD;
//         //     if (y < 0) y += MOD;
//         //     if (y >= MOD) y -= MOD;
//         //     return g;
//         // }
//     public:
//         constexpr Modular(const T& v = T(0)) : value(v % MOD) { if (value < T(0)) value += MOD; }
//         constexpr Modular(const Modular& other) : value(other.value) {}
//         Modular& operator=(const Modular& other) { value = other.value; return *this; }
//         Modular& operator=(const T& v) { value = v % MOD; if (value < T(0)) value += MOD; return *this; }
        
//         T getVal() const { return value; }
//         Modular& setVal(const T& v) { value = v % MOD; if (value < T(0)) value += MOD; return *this; }

//         Modular operator-() const {
//             Modular res(*this);
//             if (res.value != T(0)) res.value = MOD - res.value;
//             return res;
//         }
//         friend Modular operator+(const Modular& a, const Modular& b) { 
//             Modular res(a);
//             if ((res.value += b.value) >= MOD) res.value -= MOD;
//             return res;
//         }
//         friend Modular operator-(const Modular& a, const Modular& b) { 
//             Modular res(a);
//             if ((res.value -= b.value) < T(0)) res.value += MOD;
//             return res;
//         }
//         friend Modular operator*(const Modular& a, const Modular& b) { return Modular((MCT) a.value * (MCT) b.value % MOD); }
//         Modular& operator+=(const Modular& other) { 
//             if ((value += other.value) >= MOD) value -= MOD;
//             return *this; 
//         }
//         Modular& operator-=(const Modular& other) { 
//             if ((value -= other.value) < 0) { value += MOD; } 
//             return *this; 
//         }
//         Modular& operator*=(const Modular& other) { 
//             value = (MCT) value * (MCT) other.value % MOD; 
//             return *this; 
//         }
//         template <typename U>
//         Modular fPow(U exp) const {
//             Modular result(1);
//             T base = value;
//             while (exp) {
//                 if (exp & 1) result.value = (MCT) result.value * (MCT) base % MOD;
//                 base = (MCT) base * (MCT) base % MOD;
//                 exp >>= 1;
//             }
//             return result;
//         }
//         template <typename U>
//         Modular& fPowSelf(U exp) {
//             T base = value;
//             value = 1;
//             while (exp) {
//                 if (exp & 1) value = (MCT) value * (MCT) base % MOD;
//                 base = (MCT) base * (MCT) base % MOD;
//                 exp >>= 1;
//             }
//             return *this;
//         }
//         Modular inv() const {
//             return fPow(MOD - 2);
//             // T x, y;
//             // T g = exgcd(value, MOD, x, y);
//             // assert(g == 1);
//             // return Modular(x);
//         }
//         Modular& invSelf() {
//             return fPowSelf(MOD - 2);
//             // T x, y;
//             // T g = exgcd(value, MOD, x, y);
//             // assert(g == 1); 
//             // value = x;
//             // return *this;
//         }
//         // 除法运算
//         friend Modular operator/(const Modular& a, const Modular& b) { return a * b.inv(); }
//         Modular& operator/=(const Modular& other) { return *this *= other.inv(); }
//         // 比较运算
//         friend bool operator==(const Modular& a, const Modular& b) { return a.value == b.value; }
//         friend bool operator!=(const Modular& a, const Modular& b) { return a.value != b.value; }
//         friend std::ostream& operator<<(std::ostream& os, const Modular& m) { return os << m.value; }
//         friend std::istream& operator>>(std::istream& is, Modular& m) { 
//             T v; 
//             is >> v; 
//             m.setVal(v); 
//             return is; 
//         }
//     };
// }
// #endif
// #include <cstdio>
// #include <cstddef>
// #include <cctype>
// #include <type_traits>
// #include <string>
// template<size_t BUF_SIZE>
// class FastIO {
// private:
//     char outdata[BUF_SIZE], indata[BUF_SIZE];
//     size_t n, outidx, inidx;
//     FILE* inFile;
//     FILE* outFile;
//     // int floatPrecision = 6;
//     // bool useScientific = true;
// public:
//     FastIO(FILE* in = stdin, FILE* out = stdout) : n(0), outidx(0), inidx(0), inFile(in), outFile(out) {}

//     // inline void setPrecision(int p) { floatPrecision = p; }
//     // inline void setScientific(bool enable) { useScientific = enable; }

//     inline void putchar(char c) {
//         outdata[outidx++] = c;
//         if (outidx == BUF_SIZE) {
//             std::fwrite(outdata, 1, BUF_SIZE, outFile);
//             outidx = 0;
//         }
//     }
//     inline void flush() { if (outidx) std::fwrite(outdata, 1, outidx, outFile), outidx = 0; }
//     inline char getchar() {
//         if (inidx >= n) {
//             n = std::fread(indata, 1, BUF_SIZE, inFile);
//             inidx = 0;
//             if (n == 0) return -1;
//         }
//         return indata[inidx++];
//     }
//     template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
//     inline FastIO& operator<<(T x) {
//         static char s[40];
//         if (x < 0) putchar('-'), x = -x;
//         int n = 0;
//         do s[n++] = x % 10 | 0x30, x /= 10;
//         while (x);
//         while (n--) putchar(s[n]);
//         return *this;
//     }
//     template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
//     inline FastIO& operator>>(T& x) {
//         x = 0;
//         char ch = getchar();
//         bool flag = false;
//         while (!std::isdigit(ch)) {
//             if (ch == '-') flag = true;
//             ch = getchar();
//         }
//         while (std::isdigit(ch)) {
//             x = (x << 3) + (x << 1) + (ch ^ 0x30);
//             ch = getchar();
//         }
//         if (flag) x = -x;
//         return *this;
//     }
//     template<typename T, typename std::enable_if<std::is_floating_point<T>::value, int>::type = 0>
//     inline FastIO& operator>>(T& x) {
//         x = 0;
//         bool neg = false;
//         char ch = getchar();
//         while (!std::isdigit(ch) && ch != '.') {
//             if (ch == '-') neg = true;
//             ch = getchar();
//         }
//         while (std::isdigit(ch)) {
//             x = x * 10 + (ch ^ 0x30);
//             ch = getchar();
//         }
//         if (ch == '.') {
//             ch = getchar();
//             T div = static_cast<T>(1);
//             while (isdigit(ch)) {
//                 div /= 10;
//                 x += (ch ^ 0x30) * div;
//                 ch = getchar();
//             }
//         }
//         if (neg) x = -x;
//         if (ch == 'E' || ch == 'e') {
//             ch = getchar();
//             neg = false;
//             if (ch == '+') {
//                 ch = getchar();
//             } else if (ch == '-') {
//                 neg = true;
//                 ch = getchar();
//             }
//             int exp = 0;
//             while (isdigit(ch)) {
//                 exp = (exp << 3) + (exp << 1) + (ch ^ 0x30);
//                 ch = getchar();
//             }
//             T base = 10;
//             if (neg) {
//                 while (exp) {
//                     if (exp & 1) x /= base;
//                     base *= base;
//                     exp >>= 1;
//                 }
//             } else {
//                 while (exp) {
//                     if (exp & 1) x *= base;
//                     base *= base;
//                     exp >>= 1;
//                 }
//             }
//         }
//         return *this;
//     }
//     // template<typename T, typename std::enable_if<std::is_floating_point<T>::value, int>::type = 0>
//     // inline FastIO& operator<<(T x) {
//     //     if (std::isnan(x)) return putchar('n'), putchar('a'), putchar('n'), *this;
//     //     if (std::isinf(x)) {
//     //         if (x < 0) putchar('-');
//     //         putchar('i'), putchar('n'), putchar('f');
//     //         return *this;
//     //     }
//     //     if (x < 0) {
//     //         putchar('-');
//     //         x = -x;
//     //     }
//     //     int exp10 = 0;
//     //     if (useScientific && (x != 0.0) && (x < 1e-4 || x >= 1e6)) {
//     //         exp10 = static_cast<int>(std::floor(std::log10(x)));
//     //         x /= std::pow(10.0, exp10);
//     //     }
//     //     T intPart;
//     //     T fracPart = std::modf(x, &intPart);
//     //     static char buf[1024];
//     //     int n = 0;
//     //     if (intPart < 1) buf[n++] = '0';
//     //     else {
//     //         while (intPart >= 1) {
//     //             T tmp = std::floor(std::fmod(intPart, 10));
//     //             buf[n++] = static_cast<int>(tmp + 1e-4) | 0x30;
//     //             intPart = std::floor(intPart / 10);
//     //         }
//     //     }
//     //     while (n--) putchar(buf[n]);
//     //     if (floatPrecision > 0) {
//     //         putchar('.');
//     //         for (int i = 0; i < floatPrecision; ++i) {
//     //             fracPart *= 10;
//     //             int digit = fracPart + 1e-4;
//     //             buf[fracLen++] =  | 0x30;
//     //             fracPart -= digit;
//     //         }
//     //         // // 去除尾随0
//     //         // while (fracLen > 0 && fracBuf[fracLen - 1] == '0') fracLen--;
//     //         // for (int i = 0; i < fracLen; ++i) putchar(fracBuf[i]);
//     //     }
//     //     if (exp10 != 0) {
//     //         putchar('e');
//     //         if (exp10 < 0) putchar('-'), exp10 = -exp10;
//     //         static char expBuf[8];
//     //         int n = 0;
//     //         do expBuf[n++] = exp10 % 10 | 0x30, exp10 /= 10;
//     //         while (exp10);
//     //         while (n--) putchar(expBuf[n]);
//     //     }
//     //     return *this;
//     // }
//     inline FastIO& operator<<(char ch) { putchar(ch); return *this; }
//     inline FastIO& operator>>(char& ch) {
//         ch = getchar();
//         while(!std::isgraph(ch)) ch = getchar();
//         return *this;
//     }
//     inline FastIO& operator<<(const std::string& s) {
//         for (const auto& i : s) putchar(i);
//         return *this;
//     }
//     inline FastIO& operator>>(std::string& s) {
//         char ch = getchar();
//         while(!std::isgraph(ch)) ch = getchar();
//         s.clear();
//         do s.push_back(ch), ch = getchar();
//         while (std::isgraph(ch));
//         return *this;
//     }
//     ~FastIO() {
//         flush();
//     }
// };
// #include <bits/stdc++.h>
// FastIO<(1 << 20) * 4> __IOER__;
// #define cin __IOER__
// #define cout __IOER__
// #define getchar __IOER__.getchar
// #define putchar __IOER__.putchar
// #define fflush(stdout) __IOER__.flush()
// #define endl '\n'
// using namespace std;
// // using Mint = Modular::Modular<int, 998244353, unsigned long long>;
// // inline Mint funcT2TNTT(Mint x) { return x; }
// // inline Mint funcTNTT2T(Mint x) { return x; }
// // inline Mint funcNTT(size_t x) { return Mint(3).fPow(998244352 / x); } // 332748118
// int main() {
//     // ios::sync_with_stdio(false);
//     // cin.tie(nullptr);
//     int n, m;
//     cin >> n >> m;
//     Polynomial::Polynomial<double, complex<double>, Polynomial::T2TFFT, Polynomial::TFFT2T, Polynomial::expn> a(n + 1), b(m + 1);
//     // Polynomial::Polynomial<Mint, Mint, funcT2TNTT, funcTNTT2T, funcNTT> a(n + 1), b(m + 1);
//     for (auto& x: a)
//         cin >> x;
//     for (auto& x: b)
//         cin >> x;
//     a *= b;
//     for (auto& x : a)
//         cout << (int) (x + 0.5) << ' ';
//     return 0;
// }
// // int main() {
// //     ios::sync_with_stdio(false);
// //     cin.tie(nullptr);
// //     int n;
// //     cin >> n;
// //     Polynomial::Polynomial<Mint, Mint, funcT2TNTT, funcTNTT2T, funcNTT> a(n);
// //     for (auto& x: a)
// //         cin >> x;
// //     a.expSelf();
// //     for (auto& x : a)
// //         cout << x << ' ';
// //     return 0;
// // }
#endif