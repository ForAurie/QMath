# QMath
QMath 是一个万能的数学库，它打包了和数论、线性代数、多项式函数、平面几何……相关的模板。可以方便的实现求导、插值、向量运算、快速傅里叶变换（FFT）、高斯消元……

---
# LinearAlgebra

## Matrix

### 简介

自 2025.07.16 起 `Matrix` 从 `vector` 版本更新为指针版本。该版本加减乘、标量操作、转置等都已用指针加法尽量消除了寻址乘法，已是极致 cache-friendly 写法，构造、赋值、拷贝均用 `std::copy` 或 `fill_n`，`operator*`、`operator*=` 都已用局部变量缓存，避免重复解引用，没有多余的临时对象或不必要的拷贝。没有多余的虚函数或 RTTI，没有多余的内存分配。该版本 `Matrix` 单核性能已几乎优化到极致，难以有更大突破，相比于 `vector` 版本在矩阵大小中等的情况下速度提升了 $5\sim10$ 倍。更多算法、多线程相关的优化敬请期待。

**该版本未添加错误处理相关功能，请确保使用正确。**

### 位置

该类型位于 `LinearAlgebra` 文件的 `LinearAlgebra` 命名空间中。

### 使用方法

1. 构造  
 
    使用如下方法会构造出一个高为 $n$，宽为 $m$，初始值为全 $x$ 的矩阵。若不填 $x$ 则会使用 `Type(0)` 初始化矩阵中的数，请确保 `Type(0)` 是合法的，否则你需要手动修改构造函数源代码才能使用。
    ```cpp
    Matrix<Type> a(n, m, x);
    ```
    你可以同时指定 $n,m$，也可以同时将 $n,m$ 留空（同时留空会构造一个空矩阵）。但不能只指定 $n,m$ 其中一个。
    
    你还可以传入一个二维 `vector` 来构造矩阵。
    ```cpp
    Matrix<Type> a(vector<vector<Type>>(...));
    ```

2. 运算重载
    * `=`：可以将一个矩阵赋给另一个矩阵，也可以将一个二维 `vector` 赋给矩阵。
    * `+`：矩阵 $+$ 矩阵、矩阵 $+$ 数字（给矩阵中的每一个数都加上“数字”），没有重载数字 $+$ 矩阵。
    * `-`：和 `+` 类似，同样重载了矩阵 $-$ 数字。
    * `+=`：矩阵 += 矩阵、矩阵 += 数字。
    * `-=`：和 `+=` 类似。
    * `*`：矩阵 $\times$ 矩阵、矩阵 $\times$ 数字（给矩阵中的每一个数都乘上“数字”），没有重载数字 $\times$ 矩阵。
    * `*=`：矩阵 *= 矩阵，矩阵 *= 数字。
    * `%`：矩阵 % 矩阵，将两个大小形状相同的矩阵中的每个数对应相乘，然后放在结果矩阵的相应位置上。
    * `%=`：`%` 运算的 `%=` 版本。
    * `==`、`!=`：判断两个矩阵大小、形状、内容是否完全相同。
    * `(size_t row, size_t col)`：返回矩阵第 $row$ 行第 $col$ 列的值（带引用）。
    * `[]`：若传入 $i$ 则返回矩阵第 $i$ 行的起始指针。
    * `[][]`：若传入 $i,j$ 则返回矩阵第 $i$ 行第 $j$ 列的值（带引用）。
3. 一些方法：
    * `size_t N()`：返回矩阵的行数。
    * `size_t M()`：返回矩阵的列数。
    * `Matrix transpose()`：返回该矩阵转置后的矩阵。
    * `Matrix& transposeSelf()`：将自己转置，然后返回自己的引用。
    * `Matrix applyFunction(Type (*func)(Type) 或 Type (*func)(const Type&))`：创建一个大小形状相同的结果矩阵，结果矩阵中每个数 $x$ 和其在原矩阵中位置对应的数 $y$ 的关系为：$x=func(y)$，然后返回结果矩阵。
    * `Matrix& applyFunctionSelf(Type (*func)(Type) 或 Type (*func)(const Type&))`：令该矩阵中的每一个数 $x$ 变为 $func(x)$，然后返回自己的引用。
    * `Matrix& resize(size_t n, size_t m, Type x = Type(0))`：先将该矩阵**清空**，再构造一个大小为 $n\times m$，初始值为 $x$ 的矩阵作为该矩阵，然后返回自己的引用。
